
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module lander(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,

	//////////// SW //////////
	input 		    [17:0]		SW,
	
	//////////// KEY /////////
	input 			 [3:0] 		KEY,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// I2C for Audio  //////////
	output		          		I2C_SCLK,
	inout 		          		I2C_SDAT
);


wire	VGA_CTRL_CLK;
wire	AUD_CTRL_CLK;
wire	DLY_RST;

assign	AUD_ADCLRCK	=	AUD_DACLRCK;
assign	AUD_XCK		=	AUD_CTRL_CLK;

Reset_Delay			r0	(	.iCLK(CLOCK_50),.oRESET(DLY_RST)	);

Audio_PLL 		p1	(	.areset(~DLY_RST),.inclk0(CLOCK_50),.c0(AUD_CTRL_CLK));

I2C_AV_Config 		u3	(	//	Host Side
							.iCLK(CLOCK_50),
							.iRST_N(KEY[0]),
							//	I2C Side
							.I2C_SCLK(I2C_SCLK),
							.I2C_SDAT(I2C_SDAT)	);

AUDIO_DAC_ADC 			u4	(	//	Audio Side
							.oAUD_BCK(AUD_BCLK),
							.oAUD_DATA(AUD_DACDAT),
							.oAUD_LRCK(AUD_DACLRCK),
							.oAUD_inL(audio_inL), // audio data from ADC 
							.oAUD_inR(audio_inR), // audio data from ADC 
							.iAUD_ADCDAT(AUD_ADCDAT),
							.iAUD_extL(audio_outL), // audio data to DAC
							.iAUD_extR(audio_outR), // audio data to DAC
							//	Control Signals
				         .iCLK_18_4(AUD_CTRL_CLK),
							.iRST_N(DLY_RST)
							);




// reset control
//assign reset = ~KEY[2];
//assign LEDG[0] = reset;

// The data for the DACs
wire signed [15:0] audio_outL, audio_outR ;

// output from DDS units and noise
wire signed [15:0] lfsr_out;
wire signed [15:0] sine_out;

// output two sine waves in quadrature
assign audio_outR = (lfsr_out<<1) + sine_out;
assign audio_outL = (lfsr_out<<1) + sine_out ; 

LFSR_attack_decay crash(.clock(AUD_DACLRCK), 
			.reset(KEY[2]),
			.cutoff(3'd7), // cutoff from full freq to clock/(2^7)
			.gain(3'd7), // gain = 3 bit shift factor = 1 to 2^7
			.attack(4'd0), // fast rise
			.decay(4'd6),  // fairly slow fall
			.amp(16'h7FFF), // nearly full amp
			.noise_out(lfsr_out));
			
DDS sine   (.clock(AUD_DACLRCK), 
				.reset(KEY[3]),
				.increment({18'd2507, 14'b0}), 
				.phase(8'd0),
				.sine_out(sine_out));

/*
sin_wave_player swp(.iSW(SW), 
  .iCLK(CLOCK_50), 
  .iRST(KEY[0]), 
  .iAUD_ADCDAT(AUD_ADCDAT), 
  .oI2C_SCLK(I2C_SCLK),
  .oAUD_DACDAT(AUD_DACDAT), 
  .oAUD_XCK(AUD_XCK),
  .ioAUD_BCLK(AUD_BCLK),
  .ioAUD_DACLRCK(AUD_DACLRCK), 
  .ioAUD_ADCLRCK(AUD_ADCLRCK), 
  .ioI2C_SDAT(I2C_SDAT));
  */
  /*
///////audio stuff ///////
// reset control
assign reset = ~KEY[2];
//assign LEDG[0] = reset;

// The data for the DACs
wire signed [15:0] audio_outL, audio_outR ;

// output from DDS units and noise
wire signed [15:0] sine_out, fm_out, modulated_out;
wire signed [31:0] fm_depth ;

// output two sine waves in quadrature
assign audio_outR = modulated_out<<1;
assign audio_outL = fm_out<<1 ; 

////////////////////////////////////////////////
// FM Modulated main sine wave generator
sine_attack_decay sine_fm (.clock(AUD_DACLRCK), 
				.reset(reset),
				// note that increment takes input from the FM module
				.increment({7'h02, 23'b0} + fm_depth), 
				.phase(8'd0),
				.attack(4'd0), // fast rise
				.decay(4'd7),
				.amp(16'h8FFF),
				.shaped_out(modulated_out));

// generate modulation for main oscillator	
// set modulator depth with SW[3:0]
// set modulator frequency with SW[17:4]			
sine_attack_decay fm (.clock(AUD_DACLRCK), 
				.reset(reset),
				.increment({SW[17:4], 18'b0}), 
				.phase(8'd0), 
				.attack(4'd1), // fast rise
				.decay(4'd6),  // fairly slow fall
				.amp(16'h7FFF), // nearly full amp
				.shaped_out(fm_out));
// now scale the FM output to modulate the increment of the main oscillator
// shange the 2's comp to offset binary, shift, subtract off average value again
assign fm_depth = ({fm_out+16'h8000, $signed(16'b0)}>>SW[3:0]) - (32'h80000000>>SW[3:0]);
//		
*/	
endmodule

//////////////////////////////////////////////////
////////////	Linear feedback noise	///////////
//////////////////////////////////////////////////
// Input is an lowpass cutoff and a clock
// output is bandlimited white noise
// frequency cutoff is given as a power of two from 0 to 7
// where 0 means no filtering and 7 means a cutoff ~= clock/(2^7) 

module LFSR_attack_decay (clock, reset, cutoff, gain, attack, decay, amp, noise_out);
input clock, reset;
input [2:0]  cutoff, gain;
input [3:0] attack, decay ;
input [15:0] amp ;
output wire signed [15:0] noise_out;

//random number generator and lowpass filter
wire x_low_bit ; // random number gen low-order bit
reg  signed [30:0] x_rand ;//  rand number
wire signed [17:0] new_lopass, rand_bits ;
reg signed [17:0]  lopass ;
reg [15:0] amp_rise, amp_fall;
wire  [15:0] amp_rise_main, envelope ;
wire [31:0] temp_mult, temp_envelope;
wire signed [15:0] temp_noise_out;
reg [7:0] LR_clk_divider;

//generate a random number 
//right-most bit for rand number shift regs
assign x_low_bit = x_rand[27] ^ x_rand[30];
assign rand_bits = x_rand[17:0];
// LOWPASS:
// newsample = (1-alpha)*oldsample + random*alpha
// rearranging:
// newsample = oldsample + (random-oldsample)*alpha
// alpha is set from 1 to 1/128 using shifts from 0 to 7
// alpha==1 means no lopass at all. 1/128 loses almost all the input bits
//assign new_lopass = lopass + {{4{x_rand[17]}},x_rand[17:4]} - {{4{lopass[17]}},lopass[17:4]};

assign new_lopass = lopass + (rand_bits - lopass)>>>cutoff;
assign temp_noise_out = lopass[17:2]<<gain ;

always@(posedge clock) begin
	if (reset)
	begin
		x_rand <= 31'h55555555;
		lopass <= 18'h0 ;
		amp_fall <= amp ; 
		amp_rise <= amp ;
	end
	else begin
		x_rand <= {x_rand[29:0], x_low_bit} ;
		lopass <= new_lopass ;
	end
	
	LR_clk_divider = LR_clk_divider + 1;
	if (LR_clk_divider == 0) begin
		amp_fall <= amp_fall - (amp_fall>>decay) ;
		amp_rise <= amp_rise - (amp_rise>>attack);
	end	
end

// form (1-exp(-t/tau)) for the attack phase
assign amp_rise_main =  amp - amp_rise;
// product of rise and fall exponentials is the amplitude envelope
assign temp_envelope = amp_rise_main * amp_fall ;
assign envelope = temp_envelope[31:16]  ;		
assign temp_mult = (temp_noise_out<<1) * $signed(envelope);
//assign shaped_out = (envelope<16'h10)? 16'd0 : temp_mult[31:16] ;
assign noise_out = temp_mult[31:16] ;
endmodule
//////////////////////////////////////////////////


//////////////////////////////////////////////////
////////////	Attack and decay sine //////////////
//////////////////////////////////////////////////
// Input is an increment, phase and a clock, attack time, decay time, initial amplitude
// output is a shaped sine wave
// Output frequency = increment * clock_rate / accumulator_bit_length
// Here accumulator_bit_length is 32 bits
// Phase is measured in samples out of 256/cycle. e.g. 64 input is 90 degrees
// attack and decay parameters are in shift-right units from a slow clock Range: 0=fast 15=very slow
module sine_attack_decay (clock, reset, increment, phase, attack, decay, amp, shaped_out);
input clock, reset;
input [31:0] increment ;
input [7:0]  phase ;
input [3:0] attack, decay ;
input [15:0] amp ;
output wire signed [15:0] shaped_out;

reg [31:0]	accumulator;
reg [7:0] LR_clk_divider; 
reg [15:0] amp_rise, amp_fall;
wire signed [15:0] sine_out ;
wire  [15:0] amp_rise_main, envelope ;
wire [31:0] temp_mult, temp_envelope;

always@(posedge clock) begin
	if (reset) begin
		accumulator <= 0;
		amp_fall <= amp ; 
		amp_rise <= amp ;
	end
	
	// increment phase accumulator
	else accumulator <= accumulator + increment  ;
	
	LR_clk_divider = LR_clk_divider + 1;
	if (LR_clk_divider == 0) begin
		amp_fall <= amp_fall - (amp_fall>>decay) ;
		amp_rise <= amp_rise - (amp_rise>>attack);
	end	
end

// form (1-exp(-t/tau)) for the attack phase
assign amp_rise_main =  amp - amp_rise;
// product of rise and fall exponentials is the amplitude envelope
assign temp_envelope = amp_rise_main * amp_fall ;
assign envelope = temp_envelope[31:16]  ;		

// link the accumulator to the sine lookup table
sync_rom sineTable(clock, accumulator[31:24]+phase, sine_out);
assign temp_mult = (sine_out<<1) * $signed(envelope);
//assign shaped_out = (envelope<16'h10)? 16'd0 : temp_mult[31:16] ;
assign shaped_out = temp_mult[31:16] ;

endmodule


//////////////////////////////////////////////////

//////////////////////////////////////////////////
////////////	Direct Digital Synth	//////////////
//////////////////////////////////////////////////
// Input is an increment, phase and a clock
// output is a sine wave
// Output frequency = increment * clock_rate / accumulator_bit_length
// Here accumulator_bit_length is 32 bits
// Phase is measured in samples out of 256/cycle. e.g. 64 input is 90 degrees

module DDS (clock, reset, increment, phase, sine_out);
input clock, reset;
input [31:0] increment ;
input [7:0]  phase;
output wire signed [15:0] sine_out;
reg [31:0]	accumulator;

always@(posedge clock) begin
	if (reset) accumulator <= 0;
	// increment phase accumulator
	else accumulator <= accumulator + increment  ;
end

// link the accumulator to the sine lookup table
sync_rom sineTable(clock, accumulator[31:24]+phase, sine_out);

endmodule
//////////////////////////////////////////////////

//////////////////////////////////////////////////
////////////	Linear feedback noise	///////////
//////////////////////////////////////////////////
// Input is an lowpass cutoff and a clock
// output is bandlimited white noise
// frequency cutoff is given as a power of two from 0 to 7
// where 0 means no filtering and 7 means a cutoff ~= clock/(2^7) 

module LFSR (clock, reset, cutoff, gain, noise_out);
input clock, reset;
input [2:0]  cutoff, gain;
output wire signed [15:0] noise_out;

//random number generator and lowpass filter
wire x_low_bit ; // random number gen low-order bit
reg  signed [30:0] x_rand ;//  rand number
wire signed [17:0] new_lopass, rand_bits ;
reg signed [17:0]  lopass ;

//generate a random number 
//right-most bit for rand number shift regs
assign x_low_bit = x_rand[27] ^ x_rand[30];
assign rand_bits = x_rand[17:0];
// LOWPASS:
// newsample = (1-alpha)*oldsample + random*alpha
// rearranging:
// newsample = oldsample + (random-oldsample)*alpha
// alpha is set from 1 to 1/128 using shifts from 0 to 7
// alpha==1 means no lopass at all. 1/128 loses almost all the input bits
//assign new_lopass = lopass + {{4{x_rand[17]}},x_rand[17:4]} - {{4{lopass[17]}},lopass[17:4]};

assign new_lopass = lopass + (rand_bits - lopass)>>>cutoff;
assign noise_out = lopass[17:2]<<gain ;

always@(posedge clock) begin
	if (reset)
	begin
		x_rand <= 31'h55555555;
		lopass <= 18'h0 ;
	end
	else begin
		x_rand <= {x_rand[29:0], x_low_bit} ;
		lopass <= new_lopass ;
	end
end
endmodule
//////////////////////////////////////////////////










module sin_wave_player(iSW, 
							  iCLK, 
							  iRST, 
                       iAUD_ADCDAT, 
							  oI2C_SCLK,
							  oAUD_DACDAT, 
							  oAUD_XCK,
							  ioAUD_BCLK,
							  ioAUD_DACLRCK, 
							  ioAUD_ADCLRCK, 
							  ioI2C_SDAT);

input [17:0] iSW;
input iCLK;
input iRST;
inout ioI2C_SDAT;
input iAUD_ADCDAT;

output oI2C_SCLK;
inout ioAUD_BCLK;
output oAUD_DACDAT;
inout ioAUD_DACLRCK;
inout ioAUD_ADCLRCK;
output oAUD_XCK;
							  
wire	VGA_CTRL_CLK;
wire	AUD_CTRL_CLK;
wire	DLY_RST;

assign	ioAUD_ADCLRCK	=	ioAUD_DACLRCK;
assign	oAUD_XCK		=	AUD_CTRL_CLK;

Reset_Delay			r0	(	.iCLK(iCLK),.oRESET(DLY_RST)	);

Audio_PLL 		p1	(	.areset(~DLY_RST),.inclk0(iCLK),.c0(AUD_CTRL_CLK));

I2C_AV_Config 		u3	(	//	Host Side
							.iCLK(iCLK),
							.iRST_N(iRST),
							//	I2C Side
							.I2C_SCLK(iI2C_SCLK),
							.I2C_SDAT(ioI2C_SDAT)	);

AUDIO_DAC_ADC 			u4	(	//	Audio Side
							.oAUD_BCK(ioAUD_BCLK),
							.oAUD_DATA(oAUD_DACDAT),
							.oAUD_LRCK(ioAUD_DACLRCK),
							.oAUD_inL(audio_inL), // audio data from ADC 
							.oAUD_inR(audio_inR), // audio data from ADC 
							.iAUD_ADCDAT(iAUD_ADCDAT),
							.iAUD_extL(audio_outL), // audio data to DAC
							.iAUD_extR(audio_outR), // audio data to DAC
							//	Control Signals
				         .iCLK_18_4(AUD_CTRL_CLK),
							.iRST_N(DLY_RST)
							);

/// audio stuff /////////////////////////////////////////////////
// The data for the DACs
wire signed [15:0] audio_outL, audio_outR ;

// DDS sine wave generator
// for two phase-locked outputs
reg [31:0]	DDS_accum, DDS_incr;
wire signed [15:0] sine_out, sine_out_90;

// output two sine waves in quadrature
assign audio_outR = sine_out;
assign audio_outL = sine_out_90;

// DDS accumulator at audio rate
always@(posedge ioAUD_DACLRCK) begin
	// generate variable frequency
	// DDS F = (SW*2^14)*(audio clock rate)/(2^32)
	// 
	DDS_accum = DDS_accum + {iSW[17:0], 14'b0} ;
end

//hook up the ROM table for sine generation
sync_rom sineTable(iCLK, DDS_accum[31:24], sine_out);
//hook up the ROM table for 90 degrees phase shift (64/256)
sync_rom sineTable_90(iCLK, DDS_accum[31:24]+8'd64, sine_out_90);
endmodule
